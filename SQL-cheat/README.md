![](https://pgdv.ru/images/blog/kursy-obucheniya-sql/sql-0-min.jpg)

## Шпаргалка SQL

0. [SQL](#Structured-Query-Language)
5. [SELECT](#Базовый-синтаксис-SQL-команды-SELECT)
6. [AS](#SQL-псевдонимы)
7. [WHERE](#Условный-оператор-WHERE)
8. [INSERT](#Добавление-данных-оператор-INSERT)
9. [CASE](#Функция-CASE-в-MySQL)
10. [IF](#Функция-IF-в-MySQL)
11. [IFNULL](#Функция-IFNULL-в-MySQL)
12. [COALESCE](#Функция-COALESCE-в-MySQL)
13. [DISTINCT](#Выборка-уникальных-значений-Оператор-DISTINCT)
14. [IN](#Операторы-фильтрации)
15. [BETWEEN](#Оператор-BETWEEN)
16. [LIKE](#Операторы-LIKE-и-REGEXP)
17. [REGEXP](#Операторы-LIKE-и-REGEXP)
18. [IS NULL](#IS-NULL)
19. [ORDER BY](#Сортировка-ORDER-BY)
20. [LIMIT](#Получение-диапазона-строк-Оператор-LIMIT)
21. [Агрегатные функции](#Агрегатные-функции)
22. [GROUP BY](#Группировка)
23. [HAVING](#Фильтрация-групп-HAVING)
24. [Подзапросы](#Подзапросы)
25. [EXISTS](#Оператор-EXISTS)
26. [Неявное соединение таблиц](#Неявное-соединение-таблиц)
27. [Inner Join](#Inner-Join)
28. [Outer Join](#Outer-Join)
29. [UNION](#UNION)
30. [VIEW](#Представления-VIEW-в-MySQL)

## Structured Query Language
**SQL** - декларативный язык структурированных запросов, с помощью которого пишутся специальные запросы (_скрипты, инструкции_) к базе данных для получения данных и манипулирования ими.

Язык SQL представляет собой набор операторов, которые делятся на определенные группы со своими назначениями. В сокращенном виде эти группы называются **DDL**, **DML**, **DCL** и **TCL**.

## DDL – Data Definition Language

**Data Definition Language (DDL)** – это группа операторов **определения** данных. Другими словами, с помощью операторов, входящих в эту группы, мы определяем структуру базы данных и работаем с объектами этой базы, т.е. создаем, изменяем и удаляем их.

В эту группу входят следующие операторы:

* **CREATE** – используется для создания объектов базы данных;
* **ALTER** – используется для изменения объектов базы данных;
* **DROP** – используется для удаления объектов базы данных.

## DML – Data Manipulation Language

**Data Manipulation Language (DML)** – это группа операторов для манипуляции данными. С помощью этих операторов мы можем добавлять, изменять, удалять и выгружать данные из базы, т.е. манипулировать ими.

В эту группу входят самые распространённые операторы языка SQL:

* **SELECT** – осуществляет выборку данных;
* **INSERT** – добавляет новые данные;
* **UPDATE** – изменяет существующие данные;
* **DELETE** – удаляет данные.

## DCL – Data Control Language

**Data Control Language (DCL)** – группа операторов определения доступа к данным. Иными словами, это операторы для управления разрешениями, с помощью них мы можем разрешать или запрещать выполнение определенных операций над объектами базы данных.

## TCL – Transaction Control Language

**Transaction Control Language (TCL)** – группа операторов для управления транзакциями. Транзакция – это команда или блок команд (инструкций), которые успешно завершаются как единое целое, при этом в базе данных все внесенные изменения фиксируются на постоянной основе или отменяются, т.е. все изменения, внесенные любой командой, входящей в транзакцию, будут отменены.

-------------------------------------------

## Базовый синтаксис SQL команды SELECT
[:arrow_up:В начало](#Шпаргалка-SQL)

Одна из основных функций SQL — получение данных из СУБД. Для построения всевозможных запросов к базе данных используется оператор **SELECT**. Он позволяет выполнять сложные проверки и обработку данных.

Общая структура запроса

```sql
SELECT [DISTINCT | ALL] поля_таблиц 
[FROM список_таблиц] 
[WHERE условия_на_ограничения_строк]
[GROUP BY условия_группировки]
[HAVING условия_на_ограничения_строк_после_группировки]
[ORDER BY порядок_сортировки [ASC | DESC]]
[LIMIT ограничение_количества_записей]
```

* **DISTINCT** используется для исключения повторяющихся строк из результата
* **ALL** (по умолчанию знак * ) используется для получения всех данных, в том числе и повторений
* **FROM** перечисляет используемые в запросе таблицы из базы данных
* **WHERE** условный оператор, который используется для ограничения строк по какому-либо условию
* **GROUP BY** используется для группировки строк
* **HAVING** применяется после группировки строк для фильтрации по значениям агрегатных функций
* **ORDER BY** используется для сортировки. У него есть два параметра:
* **ASC** (по умолчанию) используется для сортировки по возрастанию
* **DESC** по убыванию
* **LIMIT** используется для ограничения количества строк для вывода

---------------------------------

### SQL-псевдонимы
[:arrow_up:В начало](#Шпаргалка-SQL)

Псевдонимы используются для представления столбцов или таблиц с именем отличным от оригинального. Это может быть полезно для улучшения читабельности имён и создания более короткого наименования столбца или таблицы.

Например, если в таблице есть столбец **good_type_id**, то можно переименовать его просто в **id**, для того, чтобы сделать его более коротким и удобным в использовании в будущем.

Для создания псевдонимов используется оператор AS:

```sql
SELECT 
    good_type_id AS id 
FROM 
    GoodTypes;
```

-----------------------------------------------------

### Еще примеры:

* можно выводить любые строки и числа вместо столбцов:

```sql
SELECT 
    "Hello world", 1;
```

* для того, чтобы вывести **все данные** из таблицы Company, можно использовать символ «*», который буквально означает «все столбцы»:

```sql
SELECT 
    * 
FROM 
    Company;
```

* можно вывести любой столбец, определённый в таблице, например, town_to из таблицы Trip:

```sql
SELECT 
    town_to 
FROM 
    Trip;
```

* можно вывести несколько столбцов. Для этого их нужно перечислить через запятую:

```sql
SELECT 
    member_name, status 
FROM 
    FamilyMembers;
```

* иногда возникают ситуации, в которых нужно получить только уникальные записи, для этого можно использовать DISTINCT. Например, выведем список городов без повторений, в которые летали самолеты:

```sql
SELECT 
    DISTINCT town_to 
FROM 
    Trip;
```
-----------------------------------------------------

## Условный оператор WHERE
[:arrow_up:В начало](#Шпаргалка-SQL)

Ситуация, когда требуется сделать выборку по определенному условию, встречается очень часто, для этого в операторе **SELECT** существует параметр **WHERE**, после которого следует условие для ограничения строк. Если запись удовлетворяет этому условию, то попадает в результат, иначе отбрасывается.

Общая структура запроса с оператором WHERE

```sql
SELECT поля_таблиц FROM список_таблиц 
WHERE условия_на_ограничения_строк
[логический_оператор другое_условия_на_ограничения_строк];
```

----------------------------------------

### Операторы сравнения

Операторы сравнения служат для сравнения 2 выражений, их результатом может являться ИСТИНА (1), ЛОЖЬ (0) и NULL.

>Результат сравнения с NULL является NULL. Исключением является оператор эквивалентности.

Оператор | Описание
:--:|---
\= | Оператор - равенство
\<\=\> | Оператор - эквивалентность<br/>Аналогичный оператору равенства, с одним лишь исключением: в отличие от него, оператор эквивалентности вернет ИСТИНУ при сравнении NULL <=> NULL
\<\><br/>или<br/>!= | Оператор - неравенство
\< | Оператор - меньше
\<\= | Оператор - меньше или равно
\> | Оператор - больше
\>\= | Оператор - больше или равно

-------------------------------------

## Добавление данных оператор INSERT
[:arrow_up:В начало](#Шпаргалка-SQL)

Для добавления новых записей в таблицу предназначен оператор INSERT.

Общая структура запроса с оператором INSERT

```sql
INSERT INTO имя_таблицы [(поле_таблицы, ...)]
VALUES (значение_поля_таблицы, ...)
| SELECT поле_таблицы, ... FROM имя_таблицы ...
```

_В описанной структуре запроса необязательные параметры указаны в квадратных скобках. Вертикальной чертой обозначен альтернативный синтаксис._

Значения можно вставлять перечислением с помощью слова values, перечислив их в круглых скобках через запятую или c помощью оператора select. Таким образом, добавить новые записей можно следующими способами:

```sql
INSERT INTO Goods (good_id, good_name, type)
VALUES (5, 'Table', 2);
```

```sql
INSERT INTO Goods VALUES (5, 'Table', 2);
```

```SQL
INSERT INTO Goods 
SELECT 
    good_id, good_name, type 
FROM 
    Goods 
where 
    good_name = 2;
```

-------------------------------------------------

### Первичный ключ при добавлении новой записи

Следует помнить, что первичный ключ таблицы является уникальным значением и добавление уже существующего значения приведет к ошибке.

При добавлении новой записи с уникальными индексами выбор такого уникального значения может оказаться непростой задачей. Решением может быть дополнительный запрос, направленный на выявление максимального значения первичного ключа для генерации нового уникального значения.

```sql
INSERT INTO Goods 
SELECT 
    COUNT(*) + 1, 'Table', 2 
FROM 
    Goods;
```

В SQL введен механизм его автоматической генерации. Для этого достаточно снабдить первичный ключ good_id атрибутом AUTO_INCREMENT. Тогда при создании новой записи в качестве значения good_id достаточно передать NULL или 0 — поле автоматически получит значение, равное максимальному значению столбца good_id, плюс единица.

```sql
CREATE TABLE Goods (
	good_id INT NOT NULL AUTO_INCREMENT
	...
);
```

```sql
INSERT INTO Goods VALUES (NULL, 'Table', 2);
```
------------------------------

## Функция CASE в MySQL
[:arrow_up:В начало](#Шпаргалка-SQL)
### Функция CASE проверяет истинность набора условий и в зависимости от результата проверки может возвращать тот или иной результат. Эта функция принимает следующую форму:

```sql
CASE
    WHEN условие_1 THEN результат_1
    WHEN условие_2 THEN результат_2
    .................................
    WHEN условие_N THEN условие_N
    [ELSE альтернативный_результат]
END
```

Возьмем для примера следующую таблицу Products:

```sql
CREATE TABLE Products
(
    Id INT AUTO_INCREMENT PRIMARY KEY,
    ProductName VARCHAR(30) NOT NULL,
    Manufacturer VARCHAR(20) NOT NULL,
    ProductCount INT DEFAULT 0,
    Price DECIMAL NOT NULL
);
```

Выполним запрос к этой таблице и используем функцию CASE:

```sql
SELECT ProductName, ProductCount, 
CASE
    WHEN ProductCount = 1 
        THEN 'Товар заканчивается'
    WHEN ProductCount = 2 
        THEN 'Мало товара'
    WHEN ProductCount = 3 
        THEN 'Есть в наличии'
    ELSE 'Много товара'
END AS Category
FROM Products;
```

------------------------------
