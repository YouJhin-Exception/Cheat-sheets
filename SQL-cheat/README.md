![](https://pgdv.ru/images/blog/kursy-obucheniya-sql/sql-0-min.jpg)

## Шпаргалка SQL

0. [SQL](#Structured-Query-Language)
5. [SELECT](#Базовый-синтаксис-SQL-команды-SELECT)
6. [AS](#SQL-псевдонимы)
7. [WHERE](#Условный-оператор-WHERE)
8. [INSERT](#Добавление-данных-оператор-INSERT)
9. [CASE](#Функция-CASE-в-MySQL)
10. [IF](#Функция-IF-в-MySQL)
11. [IFNULL](#Функция-IFNULL-в-MySQL)
12. [COALESCE](#Функция-COALESCE-в-MySQL)
13. [DISTINCT](#Выборка-уникальных-значений-Оператор-DISTINCT)
14. [IN](#Операторы-фильтрации)
15. [BETWEEN](#Оператор-BETWEEN)
16. [LIKE](#Операторы-LIKE-и-REGEXP)
17. [REGEXP](#Операторы-LIKE-и-REGEXP)
18. [IS NULL](#IS-NULL)
19. [ORDER BY](#Сортировка-ORDER-BY)
20. [LIMIT](#Получение-диапазона-строк-Оператор-LIMIT)
21. [Агрегатные функции](#Агрегатные-функции)
22. [GROUP BY](#Группировка)
23. [HAVING](#Фильтрация-групп-HAVING)
24. [Подзапросы](#Подзапросы)
25. [EXISTS](#Оператор-EXISTS)
26. [Неявное соединение таблиц](#Неявное-соединение-таблиц)
27. [Inner Join](#Inner-Join)
28. [Outer Join](#Outer-Join)
29. [UNION](#UNION)
30. [VIEW](#Представления-VIEW-в-MySQL)

## Structured Query Language
**SQL** - декларативный язык структурированных запросов, с помощью которого пишутся специальные запросы (_скрипты, инструкции_) к базе данных для получения данных и манипулирования ими.

Язык SQL представляет собой набор операторов, которые делятся на определенные группы со своими назначениями. В сокращенном виде эти группы называются **DDL**, **DML**, **DCL** и **TCL**.

## DDL – Data Definition Language

**Data Definition Language (DDL)** – это группа операторов **определения** данных. Другими словами, с помощью операторов, входящих в эту группы, мы определяем структуру базы данных и работаем с объектами этой базы, т.е. создаем, изменяем и удаляем их.

В эту группу входят следующие операторы:

* **CREATE** – используется для создания объектов базы данных;
* **ALTER** – используется для изменения объектов базы данных;
* **DROP** – используется для удаления объектов базы данных.

## DML – Data Manipulation Language

**Data Manipulation Language (DML)** – это группа операторов для манипуляции данными. С помощью этих операторов мы можем добавлять, изменять, удалять и выгружать данные из базы, т.е. манипулировать ими.

В эту группу входят самые распространённые операторы языка SQL:

* **SELECT** – осуществляет выборку данных;
* **INSERT** – добавляет новые данные;
* **UPDATE** – изменяет существующие данные;
* **DELETE** – удаляет данные.

## DCL – Data Control Language

**Data Control Language (DCL)** – группа операторов определения доступа к данным. Иными словами, это операторы для управления разрешениями, с помощью них мы можем разрешать или запрещать выполнение определенных операций над объектами базы данных.

## TCL – Transaction Control Language

**Transaction Control Language (TCL)** – группа операторов для управления транзакциями. Транзакция – это команда или блок команд (инструкций), которые успешно завершаются как единое целое, при этом в базе данных все внесенные изменения фиксируются на постоянной основе или отменяются, т.е. все изменения, внесенные любой командой, входящей в транзакцию, будут отменены.

-------------------------------------------

## Базовый синтаксис SQL команды SELECT
[:arrow_up:В начало](#Шпаргалка-SQL)

Одна из основных функций SQL — получение данных из СУБД. Для построения всевозможных запросов к базе данных используется оператор **SELECT**. Он позволяет выполнять сложные проверки и обработку данных.

Общая структура запроса

```sql
SELECT [DISTINCT | ALL] поля_таблиц 
[FROM список_таблиц] 
[WHERE условия_на_ограничения_строк]
[GROUP BY условия_группировки]
[HAVING условия_на_ограничения_строк_после_группировки]
[ORDER BY порядок_сортировки [ASC | DESC]]
[LIMIT ограничение_количества_записей]
```

* **DISTINCT** используется для исключения повторяющихся строк из результата
* **ALL** (по умолчанию знак * ) используется для получения всех данных, в том числе и повторений
* **FROM** перечисляет используемые в запросе таблицы из базы данных
* **WHERE** условный оператор, который используется для ограничения строк по какому-либо условию
* **GROUP BY** используется для группировки строк
* **HAVING** применяется после группировки строк для фильтрации по значениям агрегатных функций
* **ORDER BY** используется для сортировки. У него есть два параметра:
* **ASC** (по умолчанию) используется для сортировки по возрастанию
* **DESC** по убыванию
* **LIMIT** используется для ограничения количества строк для вывода

---------------------------------

### SQL-псевдонимы
[:arrow_up:В начало](#Шпаргалка-SQL)

Псевдонимы используются для представления столбцов или таблиц с именем отличным от оригинального. Это может быть полезно для улучшения читабельности имён и создания более короткого наименования столбца или таблицы.

Например, если в таблице есть столбец **good_type_id**, то можно переименовать его просто в **id**, для того, чтобы сделать его более коротким и удобным в использовании в будущем.

Для создания псевдонимов используется оператор AS:

```sql
SELECT 
    good_type_id AS id 
FROM 
    GoodTypes;
```

-----------------------------------------------------

### Еще примеры:

* можно выводить любые строки и числа вместо столбцов:

```sql
SELECT 
    "Hello world", 1;
```

* для того, чтобы вывести **все данные** из таблицы Company, можно использовать символ «*», который буквально означает «все столбцы»:

```sql
SELECT 
    * 
FROM 
    Company;
```

* можно вывести любой столбец, определённый в таблице, например, town_to из таблицы Trip:

```sql
SELECT 
    town_to 
FROM 
    Trip;
```

* можно вывести несколько столбцов. Для этого их нужно перечислить через запятую:

```sql
SELECT 
    member_name, status 
FROM 
    FamilyMembers;
```

* иногда возникают ситуации, в которых нужно получить только уникальные записи, для этого можно использовать DISTINCT. Например, выведем список городов без повторений, в которые летали самолеты:

```sql
SELECT 
    DISTINCT town_to 
FROM 
    Trip;
```
-----------------------------------------------------

## Условный оператор WHERE
[:arrow_up:В начало](#Шпаргалка-SQL)

Ситуация, когда требуется сделать выборку по определенному условию, встречается очень часто, для этого в операторе **SELECT** существует параметр **WHERE**, после которого следует условие для ограничения строк. Если запись удовлетворяет этому условию, то попадает в результат, иначе отбрасывается.

Общая структура запроса с оператором WHERE

```sql
SELECT поля_таблиц FROM список_таблиц 
WHERE условия_на_ограничения_строк
[логический_оператор другое_условия_на_ограничения_строк];
```

----------------------------------------

### Операторы сравнения

Операторы сравнения служат для сравнения 2 выражений, их результатом может являться ИСТИНА (1), ЛОЖЬ (0) и NULL.

>Результат сравнения с NULL является NULL. Исключением является оператор эквивалентности.

Оператор | Описание
:--:|---
\= | Оператор - равенство
\<\=\> | Оператор - эквивалентность<br/>Аналогичный оператору равенства, с одним лишь исключением: в отличие от него, оператор эквивалентности вернет ИСТИНУ при сравнении NULL <=> NULL
\<\><br/>или<br/>!= | Оператор - неравенство
\< | Оператор - меньше
\<\= | Оператор - меньше или равно
\> | Оператор - больше
\>\= | Оператор - больше или равно

-------------------------------------

## Добавление данных оператор INSERT
[:arrow_up:В начало](#Шпаргалка-SQL)

Для добавления новых записей в таблицу предназначен оператор INSERT.

Общая структура запроса с оператором INSERT

```sql
INSERT INTO имя_таблицы [(поле_таблицы, ...)]
VALUES (значение_поля_таблицы, ...)
| SELECT поле_таблицы, ... FROM имя_таблицы ...
```

_В описанной структуре запроса необязательные параметры указаны в квадратных скобках. Вертикальной чертой обозначен альтернативный синтаксис._

Значения можно вставлять перечислением с помощью слова values, перечислив их в круглых скобках через запятую или c помощью оператора select. Таким образом, добавить новые записей можно следующими способами:

```sql
INSERT INTO Goods (good_id, good_name, type)
VALUES (5, 'Table', 2);
```

```sql
INSERT INTO Goods VALUES (5, 'Table', 2);
```

```SQL
INSERT INTO Goods 
SELECT 
    good_id, good_name, type 
FROM 
    Goods 
where 
    good_name = 2;
```

-------------------------------------------------

### Первичный ключ при добавлении новой записи

Следует помнить, что первичный ключ таблицы является уникальным значением и добавление уже существующего значения приведет к ошибке.

При добавлении новой записи с уникальными индексами выбор такого уникального значения может оказаться непростой задачей. Решением может быть дополнительный запрос, направленный на выявление максимального значения первичного ключа для генерации нового уникального значения.

```sql
INSERT INTO Goods 
SELECT 
    COUNT(*) + 1, 'Table', 2 
FROM 
    Goods;
```

В SQL введен механизм его автоматической генерации. Для этого достаточно снабдить первичный ключ good_id атрибутом AUTO_INCREMENT. Тогда при создании новой записи в качестве значения good_id достаточно передать NULL или 0 — поле автоматически получит значение, равное максимальному значению столбца good_id, плюс единица.

```sql
CREATE TABLE Goods (
	good_id INT NOT NULL AUTO_INCREMENT
	...
);
```

```sql
INSERT INTO Goods VALUES (NULL, 'Table', 2);
```
------------------------------

## Функция CASE в MySQL
[:arrow_up:В начало](#Шпаргалка-SQL)
### Функция CASE проверяет истинность набора условий и в зависимости от результата проверки может возвращать тот или иной результат. Эта функция принимает следующую форму:

```sql
CASE
    WHEN условие_1 THEN результат_1
    WHEN условие_2 THEN результат_2
    .................................
    WHEN условие_N THEN условие_N
    [ELSE альтернативный_результат]
END
```

Возьмем для примера следующую таблицу Products:

```sql
CREATE TABLE Products
(
    Id INT AUTO_INCREMENT PRIMARY KEY,
    ProductName VARCHAR(30) NOT NULL,
    Manufacturer VARCHAR(20) NOT NULL,
    ProductCount INT DEFAULT 0,
    Price DECIMAL NOT NULL
);
```

Выполним запрос к этой таблице и используем функцию CASE:

```sql
SELECT ProductName, ProductCount, 
CASE
    WHEN ProductCount = 1 
        THEN 'Товар заканчивается'
    WHEN ProductCount = 2 
        THEN 'Мало товара'
    WHEN ProductCount = 3 
        THEN 'Есть в наличии'
    ELSE 'Много товара'
END AS Category
FROM Products;
```

------------------------------
## Функция IF в MySQL
[:arrow_up:В начало](#Шпаргалка-SQL)
### Функция IF в зависимости от результата условного выражения возвращает одно из двух значений. Общая форма функции выглядит следующим образом:
```sql
IF(условие, значение_1, значение_2)
```

Если условие, передаваемое в качестве первого параметра, верно, то возвращается первое значение, иначе возвращается второе значение. Например:

```sql
SELECT ProductName, Manufacturer,
    IF(ProductCount > 3, 'Много товара', 'Мало товара')
FROM Products;
```

------------------------------

## Функция IFNULL в MySQL
[:arrow_up:В начало](#Шпаргалка-SQL)
### Функция IFNULL проверяет значение некоторого выражения. Если оно равно NULL, то функция возвращает значение, которое передается в качестве второго параметра:

```sql
IFNULL(выражение, значение)
```

Например, возьмем следующую таблицу

```sql
CREATE TABLE Clients
(
    Id INT AUTO_INCREMENT PRIMARY KEY,
    FirstName VARCHAR(20) NOT NULL,
    LastName VARCHAR(20) NOT NULL,
    Phone VARCHAR(20) NULL,
    Email VARCHAR(20) NULL
);
  
INSERT INTO Clients (FirstName, LastName, Phone, Email)
VALUES ('Tom', 'Smith', '+36436734', NULL),
('Bob', 'Simpson', NULL, NULL);
```

И применим при получении данных функцию IFNULL:

```sql
SELECT FirstName, LastName,
        IFNULL(Phone, 'не определено') AS Phone,
        IFNULL(Email, 'неизвестно') AS Email
FROM Clients;
```

------------------------------

## Функция COALESCE в MySQL
[:arrow_up:В начало](#Шпаргалка-SQL)
### Функция COALESCE принимает список значений и возвращает первое из них, которое не равно NULL:

```sql
COALESCE(выражение_1, выражение_2, выражение_N)
```

Например, выберем из таблицы Clients пользователей и в контактах у них определим либо телефон, либо электронный адрес, если они не равны NULL:

```sql
SELECT FirstName, LastName,
        COALESCE(Phone, Email, 'не определено') AS Contacts
FROM Clients;
```

То есть в данном случае возвращается телефон, если он определен. Если он не определен, то возвращается электронный адрес. Если и электронный адрес не определен, то возвращается строка "не определено".

------------------------------

# Запросы
## Выборка уникальных значений Оператор DISTINCT
[:arrow_up:В начало](#Шпаргалка-SQL)
### С помощью оператора DISTINCT можно выбрать уникальные данные по определенным столбцам.

К примеру, разные товары могут иметь одних и тех же производителей, и, допустим, у нас следующая таблица товаров:

```sql
CREATE TABLE Products
(
    Id INT AUTO_INCREMENT PRIMARY KEY,
    ProductName VARCHAR(30) NOT NULL,
    Manufacturer VARCHAR(20) NOT NULL,
    ProductCount INT DEFAULT 0,
    Price DECIMAL NOT NULL
);
INSERT INTO Products  (ProductName, Manufacturer, ProductCount, Price)
VALUES
('iPhone X', 'Apple', 3, 71000),
('iPhone 8', 'Apple', 3, 56000),
('Galaxy S9', 'Samsung', 6, 56000),
('Galaxy S8', 'Samsung', 2, 46000),
('Honor 10', 'Huawei', 3, 26000);
```

Выберем всех производителей:

```sql
SELECT Manufacturer FROM Products;
```
_Однако при таком запросе производители повторяются._

Теперь применим оператор **DISTINCT** для выборки уникальных значений:

```sql	
SELECT DISTINCT Manufacturer FROM Products;
```

Также мы можем задавать выборку уникальные значения по нескольким столбцам:

```sql	
SELECT DISTINCT Manufacturer, ProductCount FROM Products;
```
_В данном случае для выборки используются столбцы Manufacturer и ProductCount. Из пяти строк только для двух строк эти столбцы имеют повторяющиеся значения. Поэтому в выборке будет 4 строки._

-------------------------------------

## Операторы фильтрации
[:arrow_up:В начало](#Шпаргалка-SQL)
### Оператор IN

Оператор **IN** определяет набор значений, которые должны иметь столбцы:
```sql	
WHERE выражение [NOT] IN (выражение)
```

Выражение в скобках после IN определяет набор значений. Этот набор может вычисляться динамически на основании, например, еще одного запроса, либо это могут быть константные значения.
Например, выберем товары, у которых производитель либо Samsung, либо Xiaomi, либо Huawei:

```sql	
SELECT * FROM Products
WHERE Manufacturer IN ('Samsung', 'Xiaomi', 'Huawei');
```

Оператор **NOT**, наоборот, позволяет выбрать все строки, столбцы которых не имеют определенных значений:
```sql	
SELECT * FROM Products
WHERE Manufacturer NOT IN ('Samsung', 'Xiaomi', 'Huawei');
```

## Оператор BETWEEN
[:arrow_up:В начало](#Шпаргалка-SQL)

Оператор **BETWEEN** определяет диапазон значений с помощью начального и конечного значения, которому должно соответствовать выражение:
```sql	
WHERE выражение [NOT] BETWEEN начальное_значение AND конечное_значение
```

Например, получим все товары, у которых цена от 20 000 до 50 000 (начальное и конечное значения также включаются в диапазон):
```sql	
SELECT * FROM Products
WHERE Price BETWEEN 20000 AND 50000;
```

Если надо, наоборот, выбрать те строки, которые не попадают в данный диапазон, то добавляется оператор NOT:
```sql	
SELECT * FROM Products
WHERE Price NOT BETWEEN 20000 AND 50000;
```

Также можно использовать более сложные выражения. Например, получим товары по совокупной стоимости (цена * количество):
```sql	
SELECT * FROM Products
WHERE Price * ProductCount BETWEEN 90000 AND 150000;
```

## Операторы LIKE и REGEXP
[:arrow_up:В начало](#Шпаргалка-SQL)

Оператор **LIKE** принимает шаблон строки, которому должно соответствовать выражение.
```sql	
WHERE выражение [NOT] LIKE шаблон_строки
```
Для определения шаблона могут применяться ряд специальных символов подстановки:

Символ | Описание
:--:|---
\%  | соответствует любой подстроке, которая может иметь любое количество символов, при этом подстрока может и не содержать ни одного символа. Например, выражение WHERE ProductName LIKE 'Galaxy%' соответствует таким значениям как "Galaxy Ace 2" или "Galaxy S7"
\_ | соответствует любому одиночному символу. Например, выражение WHERE ProductName LIKE 'Galaxy S_' соответствует таким значениям как "Galaxy S7" или "Galaxy S8".

Применим оператор LIKE:
```sql	
SELECT * FROM Products
WHERE ProductName LIKE 'iPhone%';
```

**REGEXP** позволяет задать регулярное выражение, которому должно соответствовать значение столбца. В этом плане REGEXP представляет более изощренный и комплексный способ фильтрации, нежели оператор LIKE. REGEXP имеет похожий синтаксис:
```sql	
WHERE выражение [NOT] REGEXP регулярное выражение
```

Регулярное выражение может принимать следующие специальные символы:

Символ | Описание
:--:|---
\^ | указывает на начало строки
\$ | указывает на конец строки
\. | соответствует любому одиночному символу
\[символы] | соответствует любому одиночному символу из скобок
\[начальный_символ-конечный_символ] | соответствует любому одиночному символу из диапазона символов
\| | отделяет два шаблона строки, и значение должно соответствовать одну из этих шаблонов

Примеры **REGEXP**:

```sql	
WHERE ProductName REGEXP 'Phone';
``` 
>строка должна содержать "Phone", например, iPhone X, Nokia Phone N, iPhone

```sql	
WHERE ProductName REGEXP '^Phone';
```
>строка должна начинаться с "Phone", например, Phone 34, PhoneX

```sql	
WHERE ProductName REGEXP 'Phone$';
```
>строка должна заканчиваться на "Phone", например, iPhone, Nokia Phone

```sql	
WHERE ProductName REGEXP 'iPhone [78]';
```
>строка должна содержать либо iPhone 7, либо iPhone 8

```sql	
WHERE ProductName REGEXP 'iPhone [6-8]';
```
>строка должна содержать либо iPhone 6, либо iPhone 7, либо iPhone 8

Например, найдем товары, названия которых содержат либо "Phone", либо "Galaxy":

```sql	
SELECT * FROM Products
WHERE ProductName REGEXP 'Phone|Galaxy';
```

## IS NULL
[:arrow_up:В начало](#Шпаргалка-SQL)

Оператор **IS NULL** позволяет выбрать все строки, столбцы которых имеют значение NULL:

```sql	
SELECT * FROM Products
WHERE ProductCount IS NULL;
```

С помощью добавления оператора **NOT** можно, наоброт, выбрать строки, столбцы которых не имеют значения NULL:

```sql	
SELECT * FROM Products
WHERE ProductCount IS NOT NULL;
```

------------------------------------
